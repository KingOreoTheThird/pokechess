<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pokémon Chess — Lichess AI + Shiny Toggle</title>

  <!-- Pokéball favicon -->
<link rel="icon" href="pokeball.ico" type="image/x-icon">
<link rel="shortcut icon" href="pokeball.ico" type="image/x-icon">




<style>
  :root{
    --light:#f0d9b5; --dark:#b58863;
    --bg:#071022; --panel:#0f1724; --text:#eef2ff;
    --accent:#ffcb05;
  }
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,var(--bg),#071633);color:var(--text);padding:18px;box-sizing:border-box}
  .app{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:320px 1fr 320px;gap:16px;align-items:start}
  header{grid-column:1/4;display:flex;align-items:center;gap:12px}
  h1{margin:0;font-size:18px}
  .card{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.5)}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button,select,input{padding:8px;border-radius:8px;border:0;background:#0b172a;color:var(--text);cursor:pointer}
  .board-area{display:flex;flex-direction:column;align-items:center;gap:8px}
  .board-wrap{display:flex;align-items:center}
  .rank-labels{display:flex;flex-direction:column;justify-content:space-between;height:640px;color:rgba(255,255,255,0.85);font-weight:700}
  .file-labels{display:flex;justify-content:space-between;width:640px;color:rgba(255,255,255,0.85);font-weight:700}
  .board{width:640px;height:640px;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);border-radius:10px;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,0.6)}
  .square{position:relative;display:flex;align-items:center;justify-content:center;user-select:none;box-sizing:border-box;}
  .square.light{background:var(--light)}
  .square.dark{background:var(--dark)}
  .coordSmall{position:absolute;left:6px;top:6px;font-size:12px;color:rgba(0,0,0,0.6);pointer-events:none}
  .piece{position:absolute;inset:6px;display:flex;align-items:center;justify-content:center;pointer-events:none;box-sizing:border-box;padding:4px}
  .piece img{width:100%;height:100%;object-fit:contain;display:block;image-rendering:pixelated;border-radius:6px}
  .highlight{outline:6px solid rgba(255,203,5,0.16);outline-offset:-6px;border-radius:6px}
  .dot{position:absolute;width:22px;height:22px;border-radius:50%;transform:translate(-50%,-50%);left:50%;top:50%}
  .dot.move{background:rgba(5,120,255,0.9)}
  .dot.capture{background:rgba(200,40,40,0.95)}
  .moves{max-height:300px;overflow:auto;text-align:left; color: #fff}
  .small{font-size:13px;color:rgba(255,255,255,0.9)}
  .promoModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);z-index:999}
  .promoBox{background:var(--panel);padding:14px;border-radius:10px;display:flex;flex-direction:column;gap:8px;align-items:center}
  .promoGrid{display:flex;gap:8px}
  .promoGrid button{display:flex;flex-direction:column;gap:6px;align-items:center;padding:6px 8px}
  .capturedRow img{width:32px;height:32px;margin:4px}
  .captureAnim{animation:capturePop .45s ease forwards}
  @keyframes capturePop{0%{transform:scale(1);opacity:1}50%{transform:scale(1.4);opacity:1}100%{transform:scale(1);opacity:0.25}}
  /* themes (more added) */
  .theme-wood { --light:#f6ecd8; --dark:#c2a06b; --panel:#3b2f2f; --bg:#2b1f1f; --text:#fff }
  .theme-marble { --light:#f3f6f8; --dark:#c8d6df; --panel:#0f1724; --bg:#08121a; --text:#f6fbff }
  .theme-dark { --light:#8b8b8b; --dark:#444; --panel:#0b172a; --bg:#020612; --text:#e8f0ff }
  .theme-retro { --light:#f7f3d6; --dark:#e0a84b; --panel:#2b1b00; --bg:#160c01; --text:#fff }
  .theme-poke { --light:#ffe6ea; --dark:#ffd7b3; --panel:#2b0b2b; --bg:#0a0310; --text:#fff }
  .theme-classic { --light:#f0d9b5; --dark:#b58863; --panel:#fff; --bg:#f4f0e6; --text:#111 }
</style>
</head>
<body>
<header>
  <h1>Pokémon Chess — Lichess AI + Shiny Toggle</h1>
  <div style="margin-left:auto" class="controls">
    <label class="small">AI Depth <input id="aiDepth" type="range" min="1" max="6" value="2" style="vertical-align:middle"> <span id="aiDepthVal">2</span></label>
    <button id="undoBtn">Undo Ply</button>
    <button id="undoFullBtn">Undo Full Move</button>
    <button id="restartBtn">Restart</button>
    <button id="flipBtn">Flip</button>
    <select id="themeSel">
      <option value="">Default</option>
      <option value="theme-wood">Wood</option>
      <option value="theme-marble">Marble</option>
      <option value="theme-dark">Dark</option>
      <option value="theme-retro">Retro</option>
      <option value="theme-poke">Poké</option>
      <option value="theme-classic">Classic</option>
    </select>
    <button id="shinyToggleBtn" title="Toggle which side is shiny">Switch Shiny Side</button>
  </div>
</header>

<div class="app">
  <div class="card">
    <div style="font-weight:700">Controls</div>
    <div style="margin-top:8px" class="small">White = human. Black = AI (Lichess). Use the controls to customise.</div>
    <hr style="margin:10px 0">
    <div style="font-weight:700">Captured</div>
    <div style="display:flex;gap:12px;margin-top:8px">
      <div style="flex:1"><div class="small">White</div><div id="capturedWhite" class="capturedRow"></div></div>
      <div style="flex:1"><div class="small">Black (shiny)</div><div id="capturedBlack" class="capturedRow"></div></div>
    </div>
    <hr style="margin:10px 0">
    <div style="font-weight:700">Status</div>
    <div id="status" style="margin-top:8px">Loading…</div>
  </div>

  <div class="board-area card" style="padding:10px">
    <div class="board-wrap">
      <div class="rank-labels" id="rankLeft"></div>
      <div>
        <div id="board" class="board"></div>
        <div class="file-labels" id="fileLabels"></div>
      </div>
      <div class="rank-labels" id="rankRight"></div>
    </div>
    <div style="margin-top:8px;display:flex;gap:12px;align-items:center;justify-content:center">
      <div class="small">Show coords</div>
      <label class="small"><input type="checkbox" id="showCoords" checked> coords</label>
      <label class="small"><input type="checkbox" id="showLegal" checked> show legal</label>
      <label class="small"><input type="checkbox" id="dragging" checked> drag</label>
    </div>
  </div>

  <div class="card">
    <div style="font-weight:700">Moves</div>
    <div id="moves" class="moves" style="margin-top:8px"></div>
  </div>
</div>

<!-- Promotion modal -->
<div id="promoModal" class="promoModal">
  <div class="promoBox">
    <div style="font-weight:800">Promote pawn to</div>
    <div class="promoGrid">
      <button data-piece="q"><img src="https://play.pokemonshowdown.com/sprites/ani/mew.gif" width="48"><div>Mew (Q)</div></button>
      <button data-piece="r"><img src="https://play.pokemonshowdown.com/sprites/ani/snorlax.gif" width="48"><div>Snorlax (R)</div></button>
      <button data-piece="b"><img src="https://play.pokemonshowdown.com/sprites/ani/gallade.gif" width="48"><div>Gallade (B)</div></button>
      <button data-piece="n"><img src="https://play.pokemonshowdown.com/sprites/ani/rapidash.gif" width="48"><div>Rapidash (N)</div></button>
    </div>
    <div style="font-size:12px;color:rgba(255,255,255,0.7);margin-top:8px">Click to select promotion</div>
  </div>
</div>

<!-- chess.js UMD -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script>
const moveSound = new Audio('sound.mp3');
/* ========== Configuration ========== */

/* YOUR TOKEN (you provided earlier) */
const LICHESS_TOKEN = 'lip_xzHYX8rTMKB9te1RJQhl'; // keep it secret

/* Animated sprite bases */
const SPRITE_NORMAL = 'https://play.pokemonshowdown.com/sprites/ani/';
const SPRITE_SHINY  = 'https://play.pokemonshowdown.com/sprites/ani-shiny/';

/* Pokémon mapping requested (lowercase keys) */
const PIECE_POKEMON = {
  p: 'pichu',     // pawn -> Pichu
  r: 'snorlax',   // rook -> Snorlax
  n: 'rapidash',  // knight -> Rapidash
  b: 'gallade',   // bishop -> Gallade
  q: 'mew',       // queen -> Mew
  k: 'mewtwo'     // king -> Mewtwo
};

/* ========== State & UI refs ========== */
let game = new Chess();
let flipped = false;
let selected = null, legalMoves = [];
let captured = {w: [], b: []}, pendingPromotion = null;
let whiteShiny = false;  // which side uses shiny sprites
let blackShiny = true;   // default black shiny

const boardEl = document.getElementById('board');
const movesEl = document.getElementById('moves');
const statusEl = document.getElementById('status');
const capturedWhiteEl = document.getElementById('capturedWhite');
const capturedBlackEl = document.getElementById('capturedBlack');
const rankLeft = document.getElementById('rankLeft');
const rankRight = document.getElementById('rankRight');
const fileLabels = document.getElementById('fileLabels');
const aiDepthInput = document.getElementById('aiDepth');
const aiDepthVal = document.getElementById('aiDepthVal');
aiDepthVal.textContent = aiDepthInput.value;

/* ========== Helpers ========== */
function initBoardUI(){
  const files = flipped ? ['h','g','f','e','d','c','b','a'] : ['a','b','c','d','e','f','g','h'];
  fileLabels.innerHTML = '';
  files.forEach(f => { const el=document.createElement('div'); el.style.width=(640/8)+'px'; el.style.textContent=f.toUpperCase(); el.style.textAlign='center'; fileLabels.appendChild(el); });
  rankLeft.innerHTML = ''; rankRight.innerHTML = '';
  const ranks = flipped ? [1,2,3,4,5,6,7,8] : [8,7,6,5,4,3,2,1];
  ranks.forEach(r => { const el=document.createElement('div'); el.style.height=(640/8)+'px'; el.style.display='flex'; el.style.alignItems='center'; el.style.justifyContent='center'; el.textContent=r; rankLeft.appendChild(el); rankRight.appendChild(el.cloneNode(true)); });
}

function spriteUrlForPiece(piece){
  if(!piece) return '';
  const name = PIECE_POKEMON[(piece.type||'').toLowerCase()] || 'pichu';
  const useShiny = (piece.color === 'w') ? whiteShiny : blackShiny;
  const base = useShiny ? SPRITE_SHINY : SPRITE_NORMAL;
  return base + name + '.gif';
}

/* ========== Rendering ========== */
function renderAll(){ renderBoard(); renderCaptured(); renderMoves(); updateStatus(); }
function renderBoard(){
  boardEl.innerHTML = '';
  const ranks = flipped ? [1,2,3,4,5,6,7,8] : [8,7,6,5,4,3,2,1];
  const files = flipped ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
  const board = game.board();
  for(const r of ranks){
    for(const f of files){
      const idxRow = 8 - r;
      const sq = document.createElement('div');
      const isLight = ((f + r) % 2) === 0;
      sq.className = 'square ' + (isLight ? 'light' : 'dark');
      const squareName = 'abcdefgh'[f] + r;
      if(document.getElementById('showCoords').checked){
        const cs = document.createElement('div'); cs.className='coordSmall'; cs.textContent = squareName; sq.appendChild(cs);
      }
      const piece = board[idxRow][f];
      if(piece){
        const wrap = document.createElement('div'); wrap.className='piece';
        const img = document.createElement('img'); img.src = spriteUrlForPiece(piece); img.alt = piece.type;
        wrap.appendChild(img); sq.appendChild(wrap);
      }
      sq.dataset.square = squareName;
      sq.addEventListener('click', ()=>onSquareClick(squareName));
      if(document.getElementById('dragging') && document.getElementById('dragging').checked){
        sq.draggable = true;
        sq.addEventListener('dragstart', e => onDragStart(e,squareName));
        sq.addEventListener('dragover', e => e.preventDefault());
        sq.addEventListener('drop', e => { e.preventDefault(); onDrop(squareName); });
      }
      boardEl.appendChild(sq);
    }
  }

  if(selected){
    const selElem = document.querySelector(`[data-square="${selected}"]`);
    if(selElem) selElem.classList.add('highlight');
    if(document.getElementById('showLegal').checked){
      for(const mv of legalMoves){
        const el = document.querySelector(`[data-square="${mv.to}"]`);
        if(el){
          const dot = document.createElement('div'); dot.className = 'dot ' + (mv.captured ? 'capture' : 'move'); el.appendChild(dot);
        }
      }
    }
  }
  initBoardUI();
}

function renderCaptured(){
  capturedWhiteEl.innerHTML=''; capturedBlackEl.innerHTML='';
  for(const p of captured.w){ const img=document.createElement('img'); img.src = (whiteShiny ? SPRITE_SHINY : SPRITE_NORMAL) + (PIECE_POKEMON[p.type]||'pichu') + '.gif'; capturedWhiteEl.appendChild(img); }
  for(const p of captured.b){ const img=document.createElement('img'); img.src = (blackShiny ? SPRITE_SHINY : SPRITE_NORMAL) + (PIECE_POKEMON[p.type]||'pichu') + '.gif'; capturedBlackEl.appendChild(img); }
}

function renderMoves(){ movesEl.innerHTML=''; const history = game.history({verbose:true}); history.forEach((h, i)=>{ const el=document.createElement('div'); el.textContent = `${i+1}. ${h.san}`; movesEl.appendChild(el); }); movesEl.scrollTop = movesEl.scrollHeight; }
function updateStatus(){ if(game.in_checkmate()){ statusEl.textContent = `Checkmate — ${(game.turn()==='w')? 'Black (AI)' : 'White'} wins`; return; } if(game.in_stalemate()){ statusEl.textContent = 'Draw — Stalemate'; return; } if(game.in_threefold_repetition()){ statusEl.textContent = 'Draw — Threefold repetition'; return; } if(game.insufficient_material()){ statusEl.textContent = 'Draw — Insufficient material'; return; } statusEl.textContent = (game.turn()==='w' ? 'White to move' : 'Black (AI) thinking...') + (game.in_check()? ' — Check!' : ''); }

/* ========== Interaction ========== */
function onSquareClick(square){
  if(game.game_over()) return;
  if(game.turn() !== 'w') return;
  const piece = game.get(square);
  if(!selected){
    if(piece && piece.color === 'w'){ selected = square; legalMoves = game.moves({square,verbose:true}); renderAll(); }
  } else {
    const chosen = legalMoves.find(m => m.to === square);
    if(chosen){
      if(chosen.promotion){ pendingPromotion = {from: chosen.from, to: chosen.to, color: 'w'}; showPromotionModal(); return; }
      const res = game.move({from: chosen.from, to: chosen.to, promotion: 'q'});
      afterLocalMove(res);
    } else {
      if(piece && piece.color === 'w'){ selected = square; legalMoves = game.moves({square,verbose:true}); renderAll(); }
      else { if (moveObj) moveSound.play().catch(()=>{});
  selected = null; legalMoves = []; renderAll(); }
    }
  }
}

/* drag/drop */
let dragFrom = null;
function onDragStart(e,sq){ dragFrom = sq; }
function onDrop(toSq){
  if(!dragFrom) return;
  if(game.turn() !== 'w') { dragFrom = null; return; }
  const moves = game.moves({square: dragFrom, verbose:true});
  const chosen = moves.find(m=>m.to===toSq);
  if(chosen){
    if(chosen.promotion){ pendingPromotion = {from: chosen.from, to: chosen.to, color:'w'}; showPromotionModal(); dragFrom=null; return; }
    const res = game.move({from: chosen.from, to: chosen.to, promotion: 'q'});
    afterLocalMove(res);
  }
  dragFrom = null;
}

function afterLocalMove(moveObj){
  if(moveObj && moveObj.captured){ captured[ moveObj.color === 'w' ? 'b' : 'w' ].push({type: moveObj.captured}); animateCapture(moveObj.to); }
  if (moveObj) moveSound.play().catch(()=>{});
  selected = null; legalMoves = []; addMoveToHistory(moveObj); renderAll();
  if(!game.game_over()) setTimeout(()=> runAIMove(), 120); else updateStatus();
}

/* promotion modal */
const promoModal = document.getElementById('promoModal');
function showPromotionModal(){ promoModal.style.display = 'flex'; }
function hidePromotionModal(){ promoModal.style.display = 'none'; pendingPromotion = null; }
document.querySelectorAll('.promoGrid button').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const piece = btn.dataset.piece;
    if(!pendingPromotion) return;
    const {from,to} = pendingPromotion;
    const res = game.move({from,to,promotion: piece});
    if(res && res.captured) captured[ res.color === 'w' ? 'b' : 'w' ].push({type: res.captured});
    addMoveToHistory(res); hidePromotionModal(); renderAll(); if(!game.game_over()) setTimeout(()=>runAIMove(),120);
  });
});
promoModal.addEventListener('click', (e)=>{ if(e.target===promoModal){ hidePromotionModal(); } });

function animateCapture(square){ const el = document.querySelector(`[data-square="${square}"] .piece img`); if(el){ el.classList.add('captureAnim'); setTimeout(()=> el.classList.remove('captureAnim'), 500); } }
function addMoveToHistory(moveObj){ if(!moveObj) return; const el = document.createElement('div'); el.textContent = moveObj.san; movesEl.appendChild(el); movesEl.scrollTop = movesEl.scrollHeight; }

/* ========== AI: Lichess cloud-eval integration + local fallback ========== */

/* local fallback minimax (kept) */
const PIECE_VALUE = {p:100, n:320, b:330, r:500, q:900, k:20000};
function evaluateBoard(st){ let s=0; const b=st.board(); for(let r=0;r<8;r++){ for(let f=0;f<8;f++){ const p=b[r][f]; if(p){ s += (p.color==='w' ? PIECE_VALUE[p.type] : -PIECE_VALUE[p.type]); } } } return s; }
function minimax(chessState, depth, alpha, beta, maximizingPlayer){
  if(depth===0) return evaluateBoard(chessState);
  const moves = chessState.moves({verbose:true});
  if(moves.length===0) return evaluateBoard(chessState);
  if(maximizingPlayer){
    let maxEval = -Infinity;
    for(const m of moves){
      const clone = new Chess(chessState.fen()); clone.move({from:m.from,to:m.to,promotion:m.promotion||'q'});
      const v = minimax(clone, depth-1, alpha, beta, false);
      maxEval = Math.max(maxEval, v); alpha = Math.max(alpha, v); if(beta<=alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for(const m of moves){
      const clone = new Chess(chessState.fen()); clone.move({from:m.from,to:m.to,promotion:m.promotion||'q'});
      const v = minimax(clone, depth-1, alpha, beta, true);
      minEval = Math.min(minEval, v); beta = Math.min(beta, v); if(beta<=alpha) break;
    }
    return minEval;
  }
}
function pickBestMoveLocal(chessState, depth){
  const moves = chessState.moves({verbose:true});
  let best=null, bestScore=Infinity;
  for(const m of moves){
    const clone=new Chess(chessState.fen()); clone.move({from:m.from,to:m.to,promotion:m.promotion||'q'});
    const score = minimax(clone, depth-1, -Infinity, Infinity, true);
    if(score < bestScore){ bestScore = score; best = m; }
  }
  return best;
}

/* parse UCI like "e2e4" or "e7e8q" */
function uciToMoveObj(uci){
  if(!uci || uci.length < 4) return null;
  const from = uci.slice(0,2), to = uci.slice(2,4);
  let promotion = undefined;
  if(uci.length >=5) promotion = uci[4];
  return promotion ? {from,to,promotion} : {from,to};
}

/* fetch lichess cloud-eval recommended move */
async function fetchLichessBestMove(fen){
  const url = `https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}&multiPv=1`;
  try{
    const resp = await fetch(url, { headers: { 'Authorization': 'Bearer ' + LICHESS_TOKEN } });
    if(!resp.ok){
      console.warn('Lichess cloud-eval error', resp.status, resp.statusText);
      return null;
    }
    const data = await resp.json();
    // Find a moves string: try pvs[0].moves or pvs[0].pv or data.best
    let pv = null;
    if(Array.isArray(data.pvs) && data.pvs.length>0) pv = data.pvs[0];
    else if(data.pv) pv = data.pv;
    else if(data.best) return uciToMoveObj(data.best);
    if(!pv) return null;
    const movesStr = pv.moves || pv.pv || pv[0] && pv[0].moves || null;
    if(!movesStr){
      if(pv.best) return uciToMoveObj(pv.best);
      return null;
    }
    const firstUci = movesStr.trim().split(/\s+/)[0];
    return uciToMoveObj(firstUci);
  }catch(err){
    console.error('cloud-eval fetch error', err);
    return null;
  }
}

/* run AI: try Lichess then fallback */
let aiBusy = false;
async function runAIMove(){
  if(game.game_over()) { updateStatus(); return; }
  if(game.turn() !== 'b') return;
  if(aiBusy) return;
  aiBusy = true;
  updateStatus();
  try{
    const fen = game.fen();
    const depth = parseInt(aiDepthInput.value,10) || 2;
    const lichessMove = await fetchLichessBestMove(fen);
    let applied = false;
    if(lichessMove){
      const res = game.move(lichessMove);
      if(res){
        applied = true;
        if(res.captured) captured[ res.color==='w' ? 'b' : 'w' ].push({type: res.captured});
        addMoveToHistory(res);
      }
    }
    if(!applied){
      console.warn('Lichess failed or returned no move — falling back to local');
      const bestLocal = pickBestMoveLocal(new Chess(game.fen()), depth);
      if(bestLocal){
        const res2 = game.move({from: bestLocal.from, to: bestLocal.to, promotion: bestLocal.promotion || 'q'});
        if(res2 && res2.captured) captured[ res2.color==='w' ? 'b' : 'w' ].push({type: res2.captured});
        addMoveToHistory(res2);
      } else console.warn('No local move found');
    }
    renderAll();
    updateStatus();
  } finally {
    aiBusy = false;
  }
}

/* ========== Controls wiring ========== */
document.getElementById('showCoords').addEventListener('change', () => {
  renderAll();
});

document.getElementById('undoBtn').addEventListener('click', ()=>{ if(game.history().length===0) return; game.undo(); renderAll(); });
document.getElementById('undoFullBtn').addEventListener('click', ()=>{ if(game.history().length===0) return; game.undo(); if(game.history().length>0) game.undo(); renderAll(); });
document.getElementById('restartBtn').addEventListener('click', ()=>{ game.reset(); captured={w:[],b:[]}; movesEl.innerHTML=''; selected=null; legalMoves=[]; renderAll(); if(game.turn()==='b') setTimeout(runAIMove,200); });
document.getElementById('flipBtn').addEventListener('click', ()=>{ flipped = !flipped; renderAll(); });
document.getElementById('themeSel').addEventListener('change', (e)=>{ document.body.classList.remove('theme-wood','theme-marble','theme-dark','theme-retro','theme-poke','theme-classic'); if(e.target.value) document.body.classList.add(e.target.value); });
document.getElementById('aiDepth').addEventListener('input', ()=>{ aiDepthVal.textContent = aiDepthInput.value; });
document.getElementById('shinyToggleBtn').addEventListener('click', ()=>{
  // swap which side is shiny
  const tmp = whiteShiny;
  whiteShiny = blackShiny;
  blackShiny = tmp;
  // update captured display labels (we keep captured arrays but images reflect new shiny state)
  renderAll();
});

/* ========== Boot ========== */
initBoardUI();
renderAll();
if(game.turn()==='b') setTimeout(runAIMove,200);
window._chess = game;
</script>
</body>
</html>
